name: Deploy Infrastructure and Application

on:
  workflow_dispatch:
    inputs:
      docker_image:
        description: 'Docker image to deploy'
        required: false
        default: 'ghcr.io/yeborisov/devops-project:latest'
        type: string
      terraform_action:
        description: 'Terraform action (apply/plan-only)'
        required: false
        default: 'apply'
        type: choice
        options:
          - apply
          - plan-only

jobs:
  deploy:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment:
      name: production
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-central-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"
          terraform_wrapper: false

      - name: Detect GitHub runner public IP
        id: detect-ip
        run: |
          RUNNER_IP=$(curl -s https://api.ipify.org)
          if [ -z "$RUNNER_IP" ]; then
            echo "Failed to detect runner public IP"
            exit 1
          fi
          echo "RUNNER_IP=$RUNNER_IP" >> $GITHUB_OUTPUT
          echo "Detected runner IP: $RUNNER_IP"

      - name: Setup Terraform Remote State Backend (if needed)
        run: |
          BUCKET_NAME="devops-project-terraform-state"
          DYNAMODB_TABLE="devops-project-terraform-locks"
          REGION="eu-central-1"

          echo "ðŸ” Checking if Terraform backend infrastructure exists..."

          # Check if S3 bucket exists
          if aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "âœ… S3 bucket already exists: $BUCKET_NAME"
          else
            echo "ðŸ“¦ Creating S3 bucket: $BUCKET_NAME"
            aws s3api create-bucket \
              --bucket "$BUCKET_NAME" \
              --region "$REGION" \
              --create-bucket-configuration LocationConstraint="$REGION"

            echo "ðŸ”„ Enabling versioning..."
            aws s3api put-bucket-versioning \
              --bucket "$BUCKET_NAME" \
              --versioning-configuration Status=Enabled

            echo "ðŸ”’ Enabling encryption..."
            aws s3api put-bucket-encryption \
              --bucket "$BUCKET_NAME" \
              --server-side-encryption-configuration '{
                "Rules": [{
                  "ApplyServerSideEncryptionByDefault": {
                    "SSEAlgorithm": "AES256"
                  }
                }]
              }'

            echo "ðŸ›¡ï¸  Blocking public access..."
            aws s3api put-public-access-block \
              --bucket "$BUCKET_NAME" \
              --public-access-block-configuration \
                "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"

            echo "âœ… S3 bucket created and configured"
          fi

          # Check if DynamoDB table exists
          if aws dynamodb describe-table --table-name "$DYNAMODB_TABLE" --region "$REGION" &>/dev/null; then
            echo "âœ… DynamoDB table already exists: $DYNAMODB_TABLE"
          else
            echo "ðŸ—„ï¸  Creating DynamoDB table: $DYNAMODB_TABLE"
            aws dynamodb create-table \
              --table-name "$DYNAMODB_TABLE" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
              --region "$REGION"

            echo "â³ Waiting for table to be active..."
            aws dynamodb wait table-exists --table-name "$DYNAMODB_TABLE" --region "$REGION"
            echo "âœ… DynamoDB table created"
          fi

          echo "ðŸŽ‰ Terraform backend infrastructure is ready!"

      - name: Enable Terraform Backend Configuration
        run: |
          cd terraform
          # Check if backend is already uncommented
          if grep -q "^terraform {" backend.tf; then
            echo "âœ… Backend configuration already enabled"
          else
            echo "ðŸ”§ Enabling backend configuration in backend.tf"
            # Uncomment the terraform backend block
            sed -i.bak '/^# terraform {/,/^# }/s/^# //' backend.tf
            echo "âœ… Backend configuration enabled"
          fi

      - name: Create Terraform tfvars
        run: |
          cd terraform
          # Build SSH CIDR list: detected runner IP plus any additional CIDRs from secrets
          SSH_CIDRS="\"${{ steps.detect-ip.outputs.RUNNER_IP }}/32\""
          if [ -n "${{ secrets.SSH_ALLOWED_CIDR }}" ]; then
            SSH_CIDRS="$SSH_CIDRS,\"${{ secrets.SSH_ALLOWED_CIDR }}\""
          fi
          # Enable SSH only when a user-provided CIDR is present
          if [ -n "${{ secrets.SSH_ALLOWED_CIDR }}" ]; then
            ALLOW_SSH=true
          else
            ALLOW_SSH=false
          fi
          cat > terraform.tfvars <<EOF
          aws_region = "eu-central-1"
          instance_type = ""
          allow_ssh = ${ALLOW_SSH}
          ssh_allowed_cidrs = [${SSH_CIDRS}]
          ssh_key_name = "devops-project-key"
          ssh_public_key = "${{ secrets.SSH_PUBLIC_KEY }}"
          EOF

      - name: Terraform Init
        run: |
          cd terraform
          terraform init

      - name: Terraform Plan
        run: |
          cd terraform
          terraform plan -out=tfplan

      - name: Terraform Apply
        if: inputs.terraform_action == 'apply'
        run: |
          cd terraform
          terraform apply -auto-approve tfplan

      - name: Get EC2 IP from Terraform
        id: get-ip
        if: inputs.terraform_action == 'apply'
        run: |
          cd terraform
          EC2_IP=$(terraform output -raw instance_public_ip)

          if [ -z "$EC2_IP" ]; then
            echo "âŒ Failed to get EC2 IP from Terraform output"
            exit 1
          fi

          echo "EC2_IP=$EC2_IP" >> $GITHUB_OUTPUT
          echo "âœ… EC2 instance IP: $EC2_IP"

      - name: Wait for EC2 to be ready
        if: inputs.terraform_action == 'apply'
        run: |
          echo "Waiting 60 seconds for EC2 user-data to complete..."
          sleep 60

      - name: Install Ansible
        if: inputs.terraform_action == 'apply'
        run: |
          sudo apt-get update
          sudo apt-get install -y ansible

      - name: Setup SSH key
        if: inputs.terraform_action == 'apply'
        run: |
          # Fail fast and show commands (we'll temporarily disable xtrace when writing the secret)
          set -euo pipefail

          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # Write the private key without xtrace so it won't be leaked in logs
          set +x
          printf '%s\n' "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          set -x

          # Diagnostics: show size and line count of the written key (does not reveal contents)
          echo "deploy_key bytes: $(wc -c < ~/.ssh/deploy_key)"
          echo "deploy_key lines: $(wc -l < ~/.ssh/deploy_key)"
          ls -la ~/.ssh

          chmod 600 ~/.ssh/deploy_key

          # We rely on SSH's StrictHostKeyChecking=accept-new (set in Ansible inventory)
          # to add the host key on first connection instead of ssh-keyscan.

      - name: Create Ansible inventory
        if: inputs.terraform_action == 'apply'
        run: |
          cat > ansible/inventory <<EOF
          [webservers]
          ${{ steps.get-ip.outputs.EC2_IP }} ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/deploy_key ansible_ssh_common_args='-o StrictHostKeyChecking=accept-new'
          EOF

      - name: Deploy with Ansible
        if: inputs.terraform_action == 'apply'
        run: |
          cd ansible
          ansible-playbook -i inventory deploy.yml \
            -e "image=${{ inputs.docker_image }}" \
            -v

      - name: Verify deployment
        if: inputs.terraform_action == 'apply'
        run: |
          echo "Waiting 10 seconds for container to start..."
          sleep 10

          echo "Testing application endpoints:"
          curl -f http://${{ steps.get-ip.outputs.EC2_IP }}/ || (echo "Root endpoint failed" && exit 1)
          curl -f http://${{ steps.get-ip.outputs.EC2_IP }}/hostname || (echo "Hostname endpoint failed" && exit 1)

          echo "âœ… Deployment successful!"
          echo "ðŸŒ Application URL: http://${{ steps.get-ip.outputs.EC2_IP }}"
